<!--
@element vaadin-dropdown
-->

<link rel='import' href='../polymer/polymer.html'>
<link rel='import' href='vaadin-overlay.html'>

<dom-module id='vaadin-dropdown'>
  <style>
    :host {
      display: block;
      position: relative;
    }

    :host > #overlay,
    :host ::content > .dropdown-content {
      display: none;
    }

  </style>

  <template>
    <content select='.dropdown-input'></content>
    <vaadin-overlay id='overlay' position-target='[[_positionTarget]]' vertical-offset="2"></vaadin-overlay>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'vaadin-dropdown',

    properties: {
      /**
       * True if the overlay is open, false otherwise.
       */
      opened: {
        type: Boolean,
        notify: true,
        value: false,
        observer: '_openedChanged'
      },

      /**
      * Element which is focused after opening the dropdown.
      */
      focusTarget: {
        type: Object,
        value: function() {
          return Polymer.dom(this).querySelector('.dropdown-input').querySelector('input');
        }
      },

      /**
       * Vertical offset for the overlay position.
       */
      overlayVerticalOffset: {
        type: Number,
        value: 0
      },

      _positionTarget: {
        type: Object,
        value: function() {
          return this;
        }
      },

      _overlayContent: Object,

      _overlayContentHost: Object,

      _overlayContentPosition: Object,

      _overlayStyles: Array
    },

    /**
     * Fired after the `vaadin-dropdown` opens.
     *
     * @event vaadin-dropdown-opened
     */
    /**
     * Fired after the `vaadin-dropdown` closes.
     *
     * @event vaadin-dropdown-closed
     */

    attached: function() {
      Polymer.Gestures.add(document, 'tap', null);

      // We need to listen for outside taps even when the dropdown is closed
      // to blur the input.
      this._outsideTapListener = document.addEventListener('tap', function(event) {
        var eventPath = Polymer.dom(event).path;
        if (eventPath.indexOf(this) === -1 && eventPath.indexOf(this.$.overlay) === -1) {
          this.opened = false;
          this.focusTarget.blur();
        }
      }.bind(this));

      this._fillOverlay();
    },

    detached: function() {
      document.removeEventListener('tap', this._outsideTapListener);

      this._emptyOverlay();
    },

    _openedChanged: function(opened) {
      if (opened) {
        this._open();
      } else {
        this._close();
      }
    },

    ready: function() {
    },

    _open: function() {
      document.body.appendChild(this.$.overlay);

      this.$.overlay.notifyResize();

      this.focusTarget.focus();

      this.fire('vaadin-dropdown-opened');
    },

    _close: function() {
      if (this.$.overlay.parentElement == document.body) {
        document.body.removeChild(this.$.overlay);
      }

      this.fire('vaadin-dropdown-closed');
    },

    _fillOverlay: function() {
      var content = Polymer.dom(this).querySelector('.dropdown-content');
      if (content === null) return;

      this._overlayContent = content;
      this._overlayContentHost = content.domHost;
      this._overlayContentPosition = Polymer.dom(this._overlayContent).nextSibling;

      var overlayShadowRoot = Polymer.dom(this.$.overlay.root);
      /* TODO: Consider removing the scroll wrapper */
      // overlayShadowRoot.querySelector('#scroller').appendChild(content);
      overlayShadowRoot.appendChild(this._overlayContent);

      if (Polymer.Settings.useNativeShadow) {
        if (this._overlayStyles == null) {
          this._overlayStyles = [];
        }

        var overlayStyles = this._overlayStyles;
        Array.prototype.forEach.call(Polymer.dom(this._overlayContentHost.root).querySelectorAll('style'), function(domHostStyle) {
          var style = domHostStyle.cloneNode(true);
          overlayShadowRoot.appendChild(style);
          overlayStyles.push(style);
        });
      } else if (this._overlayContentHost._encapsulateStyle) {
        Polymer.StyleTransformer.dom(this._overlayContent, this._overlayContentHost.is, this._overlayContentHost._scopeCssViaAttr);
      }

      this._overlayContent = content;
    },

    _emptyOverlay: function() {
      if (this._overlayContent == null) return;

      var overlayShadowRoot = Polymer.dom(this.$.overlay.root);

      if (Polymer.Settings.useNativeShadow) {
        this._overlayStyles.forEach(function(style) {
          overlayShadowRoot.removeChild(style);
        });

        this._overlayStyles = undefined;
      } else if (this._overlayContentHost._encapsulateStyle) {
        Polymer.StyleTransformer.dom(this._overlayContent, this._overlayContentHost.is, this._overlayContentHost._scopeCssViaAttr, true);
      }

      /* TODO: Consider removing the scroll wrapper */
      // overlayShadowRoot.querySelector('#scroller').removeChild(this._overlayContent);
      overlayShadowRoot.removeChild(this._overlayContent);
      if (this._overlayContentPosition.parentNode) {
        this._overlayContentPosition.parentNode.insertBefore(this._overlayContent, this._overlayContentPosition);
      }

      this._overlayContent = undefined;
      this._overlayContentHost = undefined;
      this._overlayContentPosition = undefined;
    },

    /* TODO: Consider removing the scroll wrapper */
    // get scroller() {
    //   return Polymer.dom(this.$.overlay.root).querySelector('#scroller');
    // }
  });
</script>
