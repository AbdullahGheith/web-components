<dom-module id="fixedmode-styles">
  <template>
    <style>
      :host([fixedmode]) {
        /* Any value other than ‘none’ for the transform results in the creation of both a stacking context and
        a containing block. The object acts as a containing block for fixed positioned descendants. */
        transform: translateZ(0);
        overflow: hidden;
      }

      #header {
        position: absolute;
        top: 0;
        width: 100%;
        z-index: 1;
      }

      #items {
        /*z-index: -3;*/
      }

      td, th {
        /*will-change: translate;*/
        /*transform: translateZ(0);*/
      }

      .frozen {
        position: relative;
      }

      table {
        position: relative;
        overflow: auto;
        -webkit-overflow-scrolling: touch;
      }

      :host(:not([ios]):not([edge])) table {
        /* translate Z needed to be applied to keep scroll bars from disappearing
        when scrolling on desktop Safari.
        Also, this rule can't be applied on mobile
        Safari to keep scroll bars visible in there :-) */
        /* In Edge, this causes header to jump */
        transform: translateZ(0);
      }

      :host[edge] tbody {
        /*z-index: 1;*/
      }

      #sizer {
        position: absolute;
        display: flex;
        visibility: hidden;
        transform: translateY(-100%);
        width: 100%;
      }

    </style>
  </template>
</dom-module>

<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  vaadin.elements.grid.GridScrollBehaviorImpl = {

    properties: {
      fixedmode: {
        value: false,
        reflectToAttribute: true
      },

      _vidxOffset: {
        value: 0
      }
    },

    ready: function() {
      this.scrollTarget = this.$.table;
      this.listen(this.$.table, 'wheel', '_onWheel');
    },

    _onWheel: function(e) {
      e.preventDefault();
      this.$.table.scrollTop += e.deltaY;
      this.$.table.scrollLeft += e.deltaX;
      this._scrollHandler();
      this._ignoreScroll = true;
    },
    /**
     * Update the models, the position of the
     * items in the viewport and recycle tiles as needed.
     */
    _scrollHandler: function(e) {
      // We may ignore a duplicate invocation if this was handled on wheel event already
      if (this._ignoreScroll && e) {
        this._ignoreScroll = false;
        return;
      }
      // clamp the `scrollTop` value
      var scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));
      var delta = scrollTop - this._scrollPosition;
      var tileHeight, tileTop, kth, recycledTileSet, scrollBottom, physicalBottom;
      var ratio = this._ratio;
      var recycledTiles = 0;
      var hiddenContentSize = this._hiddenContentSize;
      var currentRatio = ratio;
      var movingUp = [];

      // track the last `scrollTop`
      this._scrollPosition = scrollTop;

      // clear cached visible indexes
      this._firstVisibleIndexVal = null;
      this._lastVisibleIndexVal = null;

      scrollBottom = this._scrollBottom;
      physicalBottom = this._physicalBottom;

      // random access
      if (Math.abs(delta) > this._physicalSize) {
        this._physicalTop += delta;
        recycledTiles =  Math.round(delta / this._physicalAverage);
      }
      // scroll up
      else if (delta < 0) {
        var topSpace = scrollTop - this._physicalTop;
        var virtualStart = this._virtualStart;

        recycledTileSet = [];

        kth = this._physicalEnd;
        currentRatio = topSpace / hiddenContentSize;

        // move tiles from bottom to top
        while (
            // approximate `currentRatio` to `ratio`
            currentRatio < ratio &&
            // recycle less physical items than the total
            recycledTiles < this._physicalCount &&
            // ensure that these recycled tiles are needed
            virtualStart - recycledTiles > 0 &&
            // ensure that the tile is not visible
            physicalBottom - this._getPhysicalSizeIncrement(kth) > scrollBottom
        ) {

          tileHeight = this._getPhysicalSizeIncrement(kth);
          currentRatio += tileHeight / hiddenContentSize;
          physicalBottom -= tileHeight;
          recycledTileSet.push(kth);
          recycledTiles++;
          kth = (kth === 0) ? this._physicalCount - 1 : kth - 1;
        }

        movingUp = recycledTileSet;
        recycledTiles = -recycledTiles;
      }
      // scroll down
      else if (delta > 0) {
        var bottomSpace = physicalBottom - scrollBottom;
        var virtualEnd = this._virtualEnd;
        var lastVirtualItemIndex = this._virtualCount-1;

        recycledTileSet = [];

        kth = this._physicalStart;
        currentRatio = bottomSpace / hiddenContentSize;

        // move tiles from top to bottom
        while (
            // approximate `currentRatio` to `ratio`
            currentRatio < ratio &&
            // recycle less physical items than the total
            recycledTiles < this._physicalCount &&
            // ensure that these recycled tiles are needed
            virtualEnd + recycledTiles < lastVirtualItemIndex &&
            // ensure that the tile is not visible
            this._physicalTop + this._getPhysicalSizeIncrement(kth) < scrollTop
          ) {

          tileHeight = this._getPhysicalSizeIncrement(kth);
          currentRatio += tileHeight / hiddenContentSize;

          this._physicalTop += tileHeight;
          recycledTileSet.push(kth);
          recycledTiles++;
          kth = (kth + 1) % this._physicalCount;
        }
      }

      this._adjustVirtualIndexOffset(delta);

      if (recycledTiles === 0) {
        // Try to increase the pool if the list's client height isn't filled up with physical items
        if (physicalBottom < scrollBottom || this._physicalTop > scrollTop) {
          this._increasePoolIfNeeded();
        }
      } else {
        this._virtualStart = this._virtualStart + recycledTiles;
        this._physicalStart = this._physicalStart + recycledTiles;
        this._update(recycledTileSet, movingUp);
      }

      this._onScroll();
    },

    _adjustVirtualIndexOffset: function(delta) {
      if (Math.abs(delta) > 10000) {
        var scale = Math.round(this._scrollPosition / this._scrollHeight * 1000) / 1000;
        var offset = scale * this.size;

        this._vidxOffset = Math.round(offset - scale * this._virtualCount);

        if (this._scrollTop === 0) {
          // fixes issues when scrolling to start but correct items are not bound. :-()
          this.scrollToIndex(0);
        }
      } else {
        // Make sure user can always swipe/wheel scroll to the start and end
        // TODO: causes a small jump in the scroll handle
        var oldOffset = this._vidxOffset || 0;
        if (this._scrollTop === 0) {
          this._vidxOffset = 0;
          this.scrollToIndex(oldOffset);
        } else if (this._scrollTop >= this._maxScrollTop) {
          this._vidxOffset = this.size - this._virtualCount;
          if (oldOffset !== this._vidxOffset) {
            this.scrollToIndex(this._virtualCount - (this._vidxOffset - oldOffset));
          }
        }
      }
    },

    _onScroll: function() {
      if (!this.fixedmode && !this.edge) {
        this.$.header.style.transform = this._getTranslate3d(0, this._scrollTop);

        Polymer.dom(this.root).querySelectorAll('.frozen').forEach(function(cell) {
          cell.style.transform = this._getTranslate3d(this._scrollLeft, 0);
        }, this);
      } else {
        Polymer.dom(this.root).querySelectorAll('tbody .frozen').forEach(function(cell) {
          cell.style.transform = this._getTranslate3d(this._scrollLeft, 0);
        }, this);

        Polymer.dom(this.root).querySelectorAll('thead th:not(.frozen)').forEach(function(cell) {
          cell.style.transform = this._getTranslate3d(-this._scrollLeft, 0);
        }, this);

        this.$.items.style.transform =
          this._getTranslate3d(-this._scrollLeft || 0, -this._scrollPosition || 0);

      }
    },

    _getTranslate3d: function(x, y) {
      return 'translate3d(' + x + 'px,' + y + 'px, 0)';
    },

  };

  vaadin.elements.grid.GridScrollBehavior = [
    vaadin.elements.grid.GridScrollBehaviorImpl
  ];

</script>
