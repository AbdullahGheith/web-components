<dom-module id="fixedmode-styles">
  <template>
    <style>
      :host {
        transform: translateZ(0);
      }

      :host([fixedmode]) {
        /* Any value other than ‘none’ for the transform results in the creation of both a stacking context and
        a containing block. The object acts as a containing block for fixed positioned descendants. */
        transform: translateZ(0);
        overflow: hidden;
      }

      #header {
        position: absolute;
        top: 0;
        width: 100%;
      }

      #items {
        z-index: -1;
      }

      td, th {
        /*will-change: translate;*/
        /*transform: translateZ(0);*/
      }

      [frozen] {
        position: relative;
      }

      table {
        position: relative;
        overflow: auto;
        -webkit-overflow-scrolling: touch;
        z-index: -2;
      }

      :host(:not([ios]):not([edge])) table {
        /* translate Z needed to be applied to keep scroll bars from disappearing
        when scrolling on desktop Safari.
        Also, this rule can't be applied on mobile
        Safari to keep scroll bars visible in there :-) */
        /* In Edge, this causes header to jump */
        transform: translateZ(0);
      }

      :host[edge] tbody {
        /*z-index: 1;*/
      }

      #sizer {
        position: absolute;
        display: flex;
        visibility: hidden;
        transform: translateY(-100%);
        width: 100%;
      }

    </style>
  </template>
</dom-module>

<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  vaadin.elements.grid.GridScrollBehaviorImpl = {

    properties: {
      fixedmode: {
        value: false,
        reflectToAttribute: true
      },

      _vidxOffset: {
        value: 0
      },

      ios: {
        value: navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/),
        reflectToAttribute: true
      }
    },

    observers: [
      '_cacheElements(columns, frozenColumns, _physicalCount)'
    ],

    ready: function() {
      this.scrollTarget = this.$.table;
      this.listen(this.$.table, 'wheel', '_onWheel');
    },

    _onWheel: function(e) {
      e.preventDefault();
      this.$.table.scrollTop += e.deltaY;
      this.$.table.scrollLeft += e.deltaX;
      this._scrollHandler();
      this._ignoreScroll = true;
    },

    _adjustVirtualIndexOffset: function(delta) {
      if (Math.abs(delta) > 10000) {
        if (this._noScale) {
          this._noScale = false;
          return;
        }

        var scale = Math.round(this._scrollPosition / this._scrollHeight * 1000) / 1000;
        var offset = scale * this.size;

        this._vidxOffset = Math.round(offset - scale * this._virtualCount);

        if (this._scrollTop === 0) {
          // fixes issues when scrolling to start but correct items are not bound. :-()
          this.scrollToIndex(0);
        }
      } else {
        // Make sure user can always swipe/wheel scroll to the start and end
        // TODO: causes a small jump in the scroll handle

        var oldOffset = this._vidxOffset || 0;
        var threshold = 1000;
        var maxShift = 100;

        // At start
        if (this._scrollTop === 0) {
          this._vidxOffset = 0;
          if (oldOffset !== this._vidxOffset) {
            this.scrollToIndex(0);
          }
        } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {
          this._vidxOffset -= Math.min(this._vidxOffset, maxShift);
          this.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset) + 1);
          this._noScale = true;
        }

        // At end
        var maxOffset = this.size - this._virtualCount;
        if (this._scrollTop >= this._maxScrollTop) {
          this._vidxOffset = maxOffset;
          if (oldOffset !== this._vidxOffset) {
            this.scrollToIndex(this._virtualCount);
          }
        } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {
          this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);
          this.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));
          this._noScale = true;
        }

      }
    },

    _scheduleReorder: function() {
      this.debounce('reorderrows', function() {
        this._physicalItems.slice(0)
          .sort(function(a, b) {
            return a.index - b.index;
          }).forEach(function(row) {
            this.$.items.appendChild(row);
          }, this);
      }, 100);
    },

    _cacheElements: function() {
      this._frozenCells = Polymer.dom(this.root).querySelectorAll('[frozen]');
    },

    _onScroll: function() {
      if (!this.fixedmode && !this.edge) {
        this.$.header.style.transform = this._getTranslate3d(0, this._scrollTop);

        var frozenCellTransform = this._getTranslate3d(this._scrollLeft, 0);
        for (var i = 0; i < this._frozenCells.length; i++) {
          this._frozenCells[i].style.transform = frozenCellTransform;
        }
      } else {
        Polymer.dom(this.root).querySelectorAll('tbody [frozen]').forEach(function(cell) {
          cell.style.transform = this._getTranslate3d(this._scrollLeft, 0);
        }, this);

        Polymer.dom(this.root).querySelectorAll('thead th:not([frozen])').forEach(function(cell) {
          cell.style.transform = this._getTranslate3d(-this._scrollLeft, 0);
        }, this);

        this.$.items.style.transform =
          this._getTranslate3d(-this._scrollLeft || 0, -this._scrollPosition || 0);

      }
    },

    _getTranslate3d: function(x, y) {
      return 'translate3d(' + x + 'px,' + y + 'px, 0)';
    },

  };

  vaadin.elements.grid.GridScrollBehavior = [
    vaadin.elements.grid.GridScrollBehaviorImpl
  ];

</script>
