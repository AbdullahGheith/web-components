<link rel="import" href="vaadin-grid-cell.html">

<dom-module id="vaadin-grid-row"></dom-module>
<dom-module id="vaadin-grid-header-row"></dom-module>

<script>
  (function() {
    var vaadinGridRowBehavior = {

      extends: 'tr',

      properties: {
        columns: Array,
        index: Number,
        cells: {
          value: []
        },
        frozenColumns: Number,
        target: Object,

        expanded: {
          value: false
        },

        _rowDetailsCell: {
          value: null
        },

        rowDetailsTemplate: Object
      },

      observers: [
        '_columnsChanged(columns, target)',
        '_indexChanged(index, cells, _rowDetailsCell)',
        '_frozenColumnsChanged(frozenColumns, cells)',
        '_rowDetailsChanged(expanded, rowDetailsTemplate, target)'
      ],

      iterateCells: function(callback) {
        this.cells.forEach(callback);
        if (this._rowDetailsCell) {
          callback(this._rowDetailsCell);
        }
      },

      _rowDetailsChanged: function(expanded, rowDetailsTemplate, target) {
        if (expanded) {
          var rowDetailsCell = document.createElement('td', 'vaadin-grid-cell');
          rowDetailsCell.setAttribute('detailscell', true);
          // Using a frozen cell as the details cell works as a handy way of
          // making it float in place
          rowDetailsCell.setAttribute('frozen', true);
          rowDetailsCell.target = target;
          rowDetailsCell.template = rowDetailsTemplate;
          Polymer.dom(this.root).appendChild(rowDetailsCell);
          Polymer.dom.flush();
          this._rowDetailsCell = rowDetailsCell;
        } else {
          if (this._rowDetailsCell) {
            Polymer.dom(this.root).removeChild(this._rowDetailsCell);
            this._rowDetailsCell = null;
            this.style.paddingBottom = '';
          }
        }

        this.iterateCells(function(cell) {
          if (cell.instance) {
            cell.instance.expanded = expanded;
          }
        });

        // Row details uses a frozen cell to need to invoke this to update cache
        this.target.$.scroller._frozenCellsChanged();
      },

      //TODO: implement support for columns.splices
      _columnsChanged: function(columns, target) {
        this.cells.forEach(function(cell) {
          Polymer.dom(this).removeChild(cell);
        }, this);

        var cells = [];

        columns.forEach(function(column) {
          var cell = document.createElement('td', 'vaadin-grid-cell');
          cell.index = this.index;
          cell.target = this.target;

          // TODO: remove hack: set a temporary height to prevent row pool
          // creation from using 1px row height.
          cell.style = 'height: 50px';
          cell.column = column;

          Polymer.dom(this).appendChild(cell);

          cells.push(cell);
        }.bind(this));

        this.cells = cells;
      },

      _frozenColumnsChanged: function(frozenColumns, cells) {
        cells.forEach(function(cell, i) {
          cell.toggleAttribute('frozen', i < frozenColumns);
          cell.toggleAttribute('last-frozen', i === frozenColumns - 1);
        });
      },

      _indexChanged: function(index, cells, _rowDetailsCell) {
        this.toggleAttribute('odd', index % 2);
        cells.forEach(function(cell) {
          cell.index = index;
        });
        if (_rowDetailsCell) {
          _rowDetailsCell.index = index;
          this.style.paddingBottom = _rowDetailsCell.style.height = _rowDetailsCell.clientHeight + 'px';
        }
      }

    };

    Polymer({
      is: 'vaadin-grid-row',

      behaviors: [
        vaadinGridRowBehavior
      ]
    });

    Polymer({
      is: 'vaadin-grid-header-row',

      behaviors: [
        vaadinGridRowBehavior
      ],

      properties: {
        headerIndex: Object
      },

      observers: [
        '_columnsChanged(columns, target, headerIndex)'
      ],

      _updateCells: function() {
        var spanning = 0;
        this.cells.forEach(function(cell, index) {

          // TODO: reset cell styles to make sure colspan have be changed dynamically.
          cell.style.display = '';
          cell.style.flexBasis = this.columns[index].minWidth || this.columns[index].width;
          cell.style.flexGrow = 1;

          if (cell.colspan > 1) {
            spanning = cell.colspan;

            var width = cell.style.flexBasis;
            var flex = cell.style.flexGrow || 1;
            for (var i = 1; i < spanning; i++) {
              width += ' + ' + (this.columns[index + i].minWidth || this.columns[index + i].width);
              flex++;
            }

            cell.style.flexBasis = 'calc(' + width + ')';
            cell.style.flexGrow = flex;
          }

          if (!cell.colspan && spanning > 0) {
            cell.style.display = 'none';
          }

          spanning = Math.max(0, spanning - 1);
        }.bind(this));
      },

      //TODO: implement support for columns.splices
      _columnsChanged: function(columns, target, headerIndex) {
        this.cells.forEach(function(cell) {
          Polymer.dom(this).removeChild(cell);
        }, this);

        var cells = [];
        var spanning = 0;

        columns.forEach(function(column, columnIndex) {
          var cell = document.createElement('th', 'vaadin-grid-header-cell');
          cell.index = this.index;
          cell.target = this.target;
          cell.column = column;
          cell.headerIndex = headerIndex;

          this.listen(cell, 'colspan-changed', '_updateCells');

          this.listen(column, 'width-changed', '_updateCells');
          this.listen(column, 'min-width-changed', '_updateCells');

          Polymer.dom(this).appendChild(cell);
          cells.push(cell);

        }.bind(this));

        this.cells = cells;
        this._updateCells();
      },

    });

  })();
</script>
