<dom-module id="vaadin-grid-data-source-styles">
  <template>
    <style>
      :host([loading]) #items {
        opacity: 0.25;
      }

      :host([loading]::before)  {
        display: block;
      }

      /* Anim */
      @keyframes vaadin-grid-spin-360 {
        100% {
          transform: rotate(360deg);
        }
      }
      @-webkit-keyframes vaadin-grid-spin-360 {
        100% {
          -webkit-transform: rotate(360deg);
          transform: rotate(360deg);
        }
      }
      :host(::before) {
        -webkit-animation: vaadin-grid-spin-360 400ms linear infinite;
        animation: vaadin-grid-spin-360 400ms linear infinite;
        border: 2px solid #03A9F4;
        border-radius: 50%;
        border-right-color: transparent;
        border-top-color: transparent;
        content: "";
        height: 16px;
        left: 50%;
        margin-left: -8px;
        margin-top: -8px;
        position: absolute;
        top: 50%;
        width: 16px;

        display: none;
      }
    </style>
  </template>
</dom-module>


<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  vaadin.elements.grid.DataSourceBehavior = {

    properties: {

      pageSize: {
        type: Number,
        value: 50
      },

      dataSource: Function,

      loading: Boolean,

      _cache: {
        value: function() {
          return {};
        }
      },

      _pendingRequests: {
        value: function() {
          return {};
        }
      },
    },

    observers: [
      'clearCache(pageSize, dataSource)'
    ],

    _getItem: function(index) {
      this.debounce('load', function() {

        // TODO: potentially heavy operation to run first visible index,
        // reconsider if performance issues occur on data binding / scrolling.
        var firstVisiblePage = this._getPageForIndex(this.$.scroller.firstVisibleIndex + this.$.scroller._vidxOffset);

        [firstVisiblePage].concat(
         this.$.scroller._physicalItems.map(function(row) {
          return this._getPageForIndex(row.index);
        }.bind(this)))
        .reduce(function(prev, curr) {
          if (prev.indexOf(curr) === -1) {
            prev.push(curr);
          }

          return prev;
        }, [])
        .forEach(this._loadPage.bind(this));
      }, 25);
    },

    _updateItems: function(page, items) {
      var map = {};
      this.$.scroller._physicalItems.map(function(row) {
        map[row.index] = row;
      });

      for(var i=0;i<this.pageSize;i++) {
        var index = page*this.pageSize + i;
        var row = map[index];
        if (row) {
          if (items) {
            var item = items[i];
            this._updateItem(row, item);

            if (row._item === item) {
              continue;
            }
            row._item = item;

            // Allow the content to determine row height
            row.style.minHeight = '';

            if (!this.$.scroller.hasAttribute('has-data')) {
              // First set of actual data set to rows, have average height re-measured
              this.$.scroller._resetAverage();
              this.$.scroller.toggleAttribute('has-data', true);
            }

            // update heights if any of the items change.
            this.debounce('update-heights', function() {
              this.$.scroller._update();
            }, 1);
          } else {
            this._updateItem(row, null);

            // Item was cleared, use current physical average as min height
            row.style.minHeight = this.$.scroller._physicalAverage + 'px';
          }
        }
      }
    },

    _loadPage: function(page) {
      if (this._cache[page]) {
        this._updateItems(page, this._cache[page]);
      } else {
        // clear items while waiting for the correct data.
        this._updateItems(page, null);
        this.loading = true;

        // make sure same page isn't requested multiple times.
        if (!this._pendingRequests[page]) {
          this._pendingRequests[page] = true;
          var opts = {page: page, pageSize: this.pageSize};
          this.dataSource(opts, function(items) {
            this._cache[page] = items;
            delete this._pendingRequests[page];
            this._updateItems(page, items);

            this.loading = this._pendingRequests.length > 0;
          }.bind(this));
        }
      }
    },

    _getPageForIndex: function(index) {
      return Math.floor(index / this.pageSize);
    },

    clearCache: function () {
      this._cache = {};
      this._pendingRequests  = {};
      this.$.scroller._update();
      this._flushItemsDebouncer();
    },

    _flushItemsDebouncer: function () {
      this.flushDebouncer('load');
    }

  };
</script>
