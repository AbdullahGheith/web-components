<script>
  window.vaadin = window.vaadin || {};
  vaadin.elements = vaadin.elements || {};
  vaadin.elements.grid = vaadin.elements.grid || {};

  vaadin.elements.grid.DataSourceBehavior = {

    properties: {

      pageSize: {
        type: Number,
        value: 50
      },

      dataSource: Function,

      _cache: {
        value: function() {
          return {};
        }
      },

      _pendingRequests: {
        value: function() {
          return {};
        }
      },
    },

    _getItem: function(index) {
      this.debounce('load', function() {

        // TODO: potentially heavy operation to run first visible index,
        // reconsider if performance issues occur on data binding / scrolling.
        var firstVisiblePage = this._getPageForIndex(this.$.scroller.firstVisibleIndex + this.$.scroller._vidxOffset);

        [firstVisiblePage].concat(
         this.$.scroller._physicalItems.map(function(row) {
          return this._getPageForIndex(row.index);
        }.bind(this)))
        .reduce(function(prev, curr) {
          if (prev.indexOf(curr) === -1) {
            prev.push(curr);
          }

          return prev;
        }, [])
        .forEach(this._loadPage.bind(this));
      }, 25);
    },

    _updateItems: function(page, items) {
      var map = {};
      this.$.scroller._physicalItems.map(function(row) {
        map[row.index] = row;
      });

      for(var i=0;i<this.pageSize;i++) {
        var index = page*this.pageSize + i;
        var row = map[index];
        if (row) {
          if (items) {
            var item = items[i];
            this._updateItem(row, item);

            if (row._item === item) {
              continue;
            }
            row._item = item;

            // Allow the content to determine row height
            row.style.minHeight = '';

            if (!this.$.scroller.hasAttribute('has-data')) {
              // First set of actual data set to rows, have average height re-measured
              this.$.scroller._resetAverage();
              this.$.scroller.toggleAttribute('has-data', true);
            }

            // update heights if any of the items change.
            this.debounce('update-heights', function() {
              this.$.scroller._update();
            }, 1);
          } else {
            this._updateItem(row, null);

            // Item was cleared, use current physical average as min height
            row.style.minHeight = this.$.scroller._physicalAverage + 'px';
          }
        }
      }
    },

    _loadPage: function(page) {
      if (this._cache[page]) {
        this._updateItems(page, this._cache[page]);
      } else {
        // clear items while waiting for the correct data.
        this._updateItems(page, null);

        // make sure same page isn't requested multiple times.
        if (!this._pendingRequests[page]) {
          this._pendingRequests[page] = true;
          var opts = {page: page, pageSize: this.pageSize};
          this.dataSource(opts, function(items) {
            this._cache[page] = items;
            delete this._pendingRequests[page];
            this._updateItems(page, items);
          }.bind(this));
        }
      }
    },

    _getPageForIndex: function(index) {
      return Math.floor(index / this.pageSize);
    },

    clearCache: function () {
      this._cache = {};
      this.$.scroller._update();
    }

  };
</script>
